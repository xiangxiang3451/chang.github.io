<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiangxiang</title>
  
  
  <link href="atom.xml" rel="self"/>
  
  <link href="http://0.0.0.8/219/241/45/var/www/"/>
  <updated>2023-10-22T10:26:54.584Z</updated>
  <id>http://0.0.0.8/219/241/45/var/www/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>base_C++</title>
    <link href="2023/10/22/base-C/"/>
    <id>2023/10/22/base-C/</id>
    <published>2023-10-22T10:26:10.000Z</published>
    <updated>2023-10-22T10:26:54.584Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-C-虚函数的定义："><a href="#1-C-虚函数的定义：" class="headerlink" title="1.C++虚函数的定义："></a>1.C++虚函数的定义：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sbase</span><br>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-析构函数（-）"><a href="#2-析构函数（-）" class="headerlink" title="2.析构函数（~）"></a>2.析构函数（~）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SFile</span> : <span class="hljs-keyword">public</span> SBase<br>&#123;<br>    ifstream file;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SFile</span>()<br>    &#123;<br>        file.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;data.txt&quot;</span>);<br>    &#125;<br>    ~<span class="hljs-built_in">SFile</span>()<br>    &#123;<br>        file.<span class="hljs-built_in">close</span>();<br>    &#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>对象所在的函数调用完毕，系统会自动执行析构函数，往往用来“善后”，清内存。。。</p></blockquote><h4 id="3-const关键字"><a href="#3-const关键字" class="headerlink" title="3.const关键字"></a>3.const关键字</h4><p>const是C++语言限定符，它限定一个变量不允许被改变，一定程度上提高安全性和可靠性相对对define来说</p><h4 id="4-typedef"><a href="#4-typedef" class="headerlink" title="4.typedef"></a>4.typedef</h4><p>typedef定义了一种类型的新别名？？？？？</p><p>可以像下面这种用法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> Myint;<br><br>Myint a=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h4 id="5-C-中的NULL和nullptr"><a href="#5-C-中的NULL和nullptr" class="headerlink" title="5.C++中的NULL和nullptr"></a>5.C++中的NULL和nullptr</h4><blockquote><p>在C语言中，NULL通常被定义为：#define NULL ((void *)0)</p><p>在C语言中把空指针赋给int和char类型时，会把void类型转换成对应的类型的指针</p><p>但是C++是强类型语言，不能实现这种隐式的类型转换</p></blockquote><h4 id="6-C-中的NEW和DELETE"><a href="#6-C-中的NEW和DELETE" class="headerlink" title="6.C++中的NEW和DELETE"></a>6.C++中的NEW和<strong>DELETE</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> date;<br><br>    Node *next;<br>&#125;;<br><br><br>Node *newNode=<span class="hljs-keyword">new</span> Node;<br><br><span class="hljs-comment">//声明一个指向Node的指针变量</span><br><span class="hljs-comment">//使用new操作符创建一个新的Node对象，并把地址赋值给指针变量*newNode</span><br>在使用<span class="hljs-keyword">new</span>分配内存时，必须手动释放已分配的内存以避免内存泄漏。可以使用<span class="hljs-keyword">delete</span>操作符来释放先前使用<span class="hljs-keyword">new</span>分配的内存空间。例如，<span class="hljs-keyword">delete</span> newNode; 可以释放newNode指向的Node对象所占用的内存空间。<br></code></pre></td></tr></table></figure><h4 id="7-简单的单向链表-还是难"><a href="#7-简单的单向链表-还是难" class="headerlink" title="7.简单的单向链表(还是难)"></a>7.简单的单向链表(还是难)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//手写一个简单的单链表</span><br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>  <span class="hljs-type">int</span> date;<span class="hljs-comment">//数据域</span><br>  Node *next;<span class="hljs-comment">//指针域。指向下个一</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    Node *head=<span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//结构体的头指针</span><br>    Node *current=<span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//指向当前的指针</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>       Node *newNode=<span class="hljs-keyword">new</span> Node;<br><br>       newNode-&gt;date=i;<span class="hljs-comment">//初始化创建的结构体对象</span><br>       newNode-&gt;next=<span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//让指针先为空</span><br><br>       <span class="hljs-keyword">if</span> (head==<span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//如果头指针为空就让头指针指向创建的对像，当前的指针指向头指针</span><br>       &#123;<br>        head=newNode;<br>        current=head;<br>       &#125;<br>       <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果头指针不为空，则指针向下指，当前的指针停留在创建的结构体对象上</span><br>        current-&gt;next=newNode;<br>        current=newNode;<br>       &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//遍历输出链表的数据域</span><br>    current=head;<span class="hljs-comment">//从头开始</span><br><br>    <span class="hljs-keyword">while</span> (current!=<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        cout&lt;&lt;current-&gt;date&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br><br>        current=current-&gt;next;<br>    &#125;<br>    <br>    cout&lt;&lt;endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br><br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-c-随机数生成器（mt19937）与rand-的区别"><a href="#8-c-随机数生成器（mt19937）与rand-的区别" class="headerlink" title="8.c++随机数生成器（mt19937）与rand()的区别"></a>8.c++随机数生成器（mt19937）与rand()的区别</h4><blockquote><p>rand（）生成的随机数有限制，如果是64位编译器，则生成的整数最大是4个字节</p><p>mt19937可以生成更大的没有限制的随机数</p></blockquote><h5 id="rand的使用"><a href="#rand的使用" class="headerlink" title="rand的使用"></a>rand的使用</h5><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">rand</span>()%(m-<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>)+<span class="hljs-built_in">n</span>;<br></code></pre></td></tr></table></figure><p>生成范围[n,m]的数</p><hr><h4 id="9-vector"><a href="#9-vector" class="headerlink" title="9.vector"></a>9.vector</h4><blockquote><p>什么是vector?</p></blockquote><p>c++中的动态数组</p><h5 id="vector中的pair-数据对"><a href="#vector中的pair-数据对" class="headerlink" title="vector中的pair(数据对)"></a>vector中的pair(数据对)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; arr;<br></code></pre></td></tr></table></figure><p>两种输出方式：</p><p>1.遍历输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-built_in">size</span>();i++)&#123;<br>       cout&lt;&lt;arr[i].first&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>&lt;&lt;arr[i].second&lt;&lt;endl;<br>   &#125;<br></code></pre></td></tr></table></figure><p>2.迭代器输出??</p><p>迭代器的意义？</p><p>迭代器是一种通用的遍历方式，所有容器都可以使用迭代器的方式去访问，修改</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; ::iterator iter;<br><br>     <span class="hljs-keyword">for</span>(iter=arr.<span class="hljs-built_in">begin</span>();iter!=arr.<span class="hljs-built_in">end</span>();iter++)&#123;<br><br>       cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;<br><br>     &#125;<br></code></pre></td></tr></table></figure><h4 id="10-递归"><a href="#10-递归" class="headerlink" title="10.递归"></a>10.递归</h4><h5 id="1-传引用"><a href="#1-传引用" class="headerlink" title="1.传引用"></a>1.传引用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test_Calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test_Calculate</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; data)</span></span>;<br></code></pre></td></tr></table></figure><p>第二行的代码传入的是引用</p><p>在递归中，需要不断调用自身函数，传入引用能保证每次函数处理完后，参数会发生改变！！！！！</p><h4 id="11-深度优先遍历-DFS-？？？"><a href="#11-深度优先遍历-DFS-？？？" class="headerlink" title="11.深度优先遍历(DFS)？？？"></a>11.深度优先遍历(DFS)？？？</h4><p>从一个点开始。沿着一条路走到底，无路可走的时候再退回之前的节点，从之前的节点其他路走下去，一直走完所有的路</p><h4 id="12：树"><a href="#12：树" class="headerlink" title="12：树"></a>12：树</h4><h5 id="1-树的遍历"><a href="#1-树的遍历" class="headerlink" title="1.树的遍历"></a>1.树的遍历</h5><blockquote><p>前序：根左右</p><p>中序：</p><p>后序</p></blockquote><h5 id="2-二叉搜索树-BST"><a href="#2-二叉搜索树-BST" class="headerlink" title="2.二叉搜索树(BST)"></a>2.二叉搜索树(BST)</h5><p>什么是二叉搜索树？</p><p>节点左边的值始终大于右边的值</p><h4 id="13-哈希表（散列表）"><a href="#13-哈希表（散列表）" class="headerlink" title="13.哈希表（散列表）"></a>13.哈希表（散列表）</h4><h5 id="1-什么是哈希表？"><a href="#1-什么是哈希表？" class="headerlink" title="1.什么是哈希表？"></a>1.什么是哈希表？</h5><p>是根据<a href="https://zh.wikipedia.org/wiki/%E9%8D%B5">键</a>（Key）而直接访问在内存存储位置的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>。也就是说，它通过计算一个关于键值的函数，将所需查询的数据<a href="https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84">映射</a>到表中一个位置来访问记录</p><p><img src="https://img-blog.csdnimg.cn/151e8217fde54b9788d052994fd5156b.png" alt="img"></p><p>所以哈希表的核心是：哈希函数 </p><p>哈希函数的设计很重要，好的哈希函数的设计可以极大提高函数的性能！！！！！！</p><p>哈希函数的设计方法：直接定址法，数字分析法，折叠法，随机数法和除留余数法等等。。。。。</p><blockquote><p>哈希表的本质是数组</p></blockquote><ol><li>数据+链表</li><li>数组+二叉树</li></ol><h5 id="2-哈希冲突"><a href="#2-哈希冲突" class="headerlink" title="2.哈希冲突"></a>2.哈希冲突</h5><p>不同的关键字通过同一个哈希函数可能得到同一哈希地址，即 key1 ≠ key2，而 Hash(key1) &#x3D; Hash(key2)，这种现象称为哈希冲突。</p><h5 id="3-哈希冲突处理"><a href="#3-哈希冲突处理" class="headerlink" title="3.哈希冲突处理"></a>3.哈希冲突处理</h5><ol><li>开放地址</li><li>链地址法</li></ol><h4 id="14-C-中的set函数"><a href="#14-C-中的set函数" class="headerlink" title="14.C++中的set函数"></a>14.C++中的set函数</h4><p>什么是set函数？</p><p>该容器里面没有重复的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">a.<span class="hljs-built_in">begin</span>()<br>a.<span class="hljs-built_in">end</span>()<br>a.<span class="hljs-built_in">count</span>()<span class="hljs-comment">//可以判断某个元素是否在集合里面,返回1或者0</span><br>a.<span class="hljs-built_in">erase</span>()<span class="hljs-comment">//删除某个元素</span><br>a.insert（）<span class="hljs-comment">//插入某个元素</span><br>a.find（）<span class="hljs-comment">//查找某个元素，返回该元素的指针（迭代器）</span><br>a.<span class="hljs-built_in">size</span>()<span class="hljs-comment">//的作用是得出集合中的元素个数。</span><br>a.<span class="hljs-built_in">empty</span>()<span class="hljs-comment">//是判断该集合是否为空。 </span><br>a.<span class="hljs-built_in">clear</span>()<span class="hljs-comment">//是用来清空集合中的元素。</span><br></code></pre></td></tr></table></figure><h4 id="15-双指针-two-pointers"><a href="#15-双指针-two-pointers" class="headerlink" title="15.双指针(two pointers)"></a>15.双指针(two pointers)</h4><h5 id="什么是双指针？"><a href="#什么是双指针？" class="headerlink" title="什么是双指针？"></a>什么是双指针？</h5><p>就是两个指针，一种技巧</p><h5 id="三种双指针"><a href="#三种双指针" class="headerlink" title="三种双指针"></a>三种双指针</h5><ol><li>普通指针：两个指针往同一方向移动</li><li>对撞指针：一头一尾往中间移动</li><li>快慢指针：慢指针+快指针</li></ol><h4 id="16-数组"><a href="#16-数组" class="headerlink" title="16.数组"></a>16.数组</h4><h5 id="1-数组元素个数"><a href="#1-数组元素个数" class="headerlink" title="1.数组元素个数"></a>1.数组元素个数</h5><blockquote><p>1.strlen();</p><p>2.sizeof()&#x2F;&#x2F;整个数组占用的空间长度除以数组第一个元素所占用的空间长度就是数组元素的个数</p><p>但是在字符数组中，末尾会有’&#x2F;0’结束符，所以返回的是数组元素个数+1  </p></blockquote><h4 id="17-广度优先搜索（BFS）"><a href="#17-广度优先搜索（BFS）" class="headerlink" title="17.广度优先搜索（BFS）"></a>17.广度优先搜索（BFS）</h4><p>解决最短路径的算法</p><h4 id="18-auto"><a href="#18-auto" class="headerlink" title="18.auto"></a>18.auto</h4><p>C++中的auto?</p><p>1.自动推断变量类型</p><p>2.for循环输出vector<int></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; testNumber = &#123; <span class="hljs-number">-2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> outNumber : testNumber)<br>&#123;<br>cout &lt;&lt; outNumber &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="19-位运算"><a href="#19-位运算" class="headerlink" title="19.位运算"></a>19.位运算</h4><p>直接操作整数对应的二进制位！！！！</p><ol><li>时间效率快</li><li>装逼</li></ol><h5 id="位运算为什么比乘除法时间效率更快？？？？？（计算机组成原理）"><a href="#位运算为什么比乘除法时间效率更快？？？？？（计算机组成原理）" class="headerlink" title="位运算为什么比乘除法时间效率更快？？？？？（计算机组成原理）"></a>位运算为什么比乘除法时间效率更快？？？？？（计算机组成原理）</h5><p>原因：</p><ol><li>从效率上来讲，移位指令占两个机器周期，而乘除法占四个机器周期</li><li>从硬件上看，移位对硬件来说更容易实现，移动一位就乘以或除以2，实现更加简单</li></ol><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p><img src="C:\Users\28158\AppData\Roaming\Typora\typora-user-images\image-20230526125145430.png" alt="image-20230526125145430"></p><h5 id="位运算高级操作"><a href="#位运算高级操作" class="headerlink" title="位运算高级操作"></a>位运算高级操作</h5><p><img src="C:\Users\28158\AppData\Roaming\Typora\typora-user-images\image-20230526125832607.png" alt="image-20230526125832607"></p><h4 id="20-二分查找-时间复杂度O-logn"><a href="#20-二分查找-时间复杂度O-logn" class="headerlink" title="20.二分查找(时间复杂度O(logn)"></a>20.二分查找(时间复杂度O(logn)</h4><p>每次都取中间值，与目标值比较。</p><p>值得注意的是边界问题！！！！！！！</p><ol><li>左闭右闭</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> target)</span> <span class="hljs-comment">//nums是数组，size是数组的大小，target是需要查找的值</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = size - <span class="hljs-number">1</span>;<span class="hljs-comment">// 定义了target在左闭右闭的区间内，[left, right]</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<span class="hljs-comment">//当left == right时，区间[left, right]仍然有效</span><br>        <span class="hljs-type">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<span class="hljs-comment">//等同于 (left + right) / 2，防止溢出</span><br>        <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>            right = middle - <span class="hljs-number">1</span>;<span class="hljs-comment">//target在左区间，所以[left, middle - 1]</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>            left = middle + <span class="hljs-number">1</span>;<span class="hljs-comment">//target在右区间，所以[middle + 1, right]</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//既不在左边，也不在右边，那就是找到答案了</span><br>            <span class="hljs-keyword">return</span> middle;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//没有找到目标值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2.左闭右开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> right = size; <span class="hljs-comment">//定义target在左闭右开的区间里，即[left, right)</span><br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<span class="hljs-comment">//因为left = right的时候，在[left, right)区间上无意义</span><br><span class="hljs-type">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<br><span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>right = middle; <span class="hljs-comment">//target 在左区间，在[left, middle)中 </span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>left = middle + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> middle;<br>&#125;<br>&#125; <br>    <span class="hljs-comment">// 没找到就返回-1</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="21-时间复杂度"><a href="#21-时间复杂度" class="headerlink" title="21.时间复杂度"></a>21.时间复杂度</h4><h5 id="1-用常数1取代运行时间中所有加法常数"><a href="#1-用常数1取代运行时间中所有加法常数" class="headerlink" title="1.用常数1取代运行时间中所有加法常数"></a>1.用常数1取代运行时间中所有加法常数</h5><p><img src="C:\Users\28158\AppData\Roaming\Typora\typora-user-images\image-20230525173156049.png" alt="image-20230525173156049"></p><p>该代码的时间复杂度是O(1);</p><h5 id="2-带有循环的代码时间复杂度"><a href="#2-带有循环的代码时间复杂度" class="headerlink" title="2.带有循环的代码时间复杂度"></a>2.带有循环的代码时间复杂度</h5><p><img src="C:\Users\28158\AppData\Roaming\Typora\typora-user-images\image-20230525173251423.png" alt="image-20230525173251423"></p><p>内层打印语句随着n的增加呈现线性增加，所以时间复杂度为O(n);</p><hr><p><img src="C:\Users\28158\AppData\Roaming\Typora\typora-user-images\image-20230525173620759.png" alt="image-20230525173620759"></p><p>n的增加会导致结果以n的二次方的规律增加</p><hr><p><img src="C:\Users\28158\AppData\Roaming\Typora\typora-user-images\image-20230525173903623.png" alt="image-20230525173903623"></p><p><img src="C:\Users\28158\AppData\Roaming\Typora\typora-user-images\image-20230525174103027.png" alt="image-20230525174103027"></p><p>该程序的时间复杂度为O(logn);</p><h4 id="22-滑动窗口（也是双指针）"><a href="#22-滑动窗口（也是双指针）" class="headerlink" title="22.滑动窗口（也是双指针）"></a>22.滑动窗口（也是双指针）</h4><p>基本模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(right&lt;s.<span class="hljs-built_in">size</span>())<br>&#123;<br>    <span class="hljs-type">char</span> c=s[right]<br>    right++;<br>     ...<span class="hljs-comment">//更新数据</span><br>    <span class="hljs-keyword">while</span>(valid==needs.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        ...   <span class="hljs-comment">//一般用于更新答案</span><br>        <span class="hljs-type">char</span> d=s[left];<br>        left++;<br>        ... <span class="hljs-comment">//更新数据</span><br>    &#125;<br>        <br>&#125;<br><span class="hljs-comment">/*windows：表示窗口    needs：表示题目要求找出的东西的集合</span><br><span class="hljs-comment">left 左指针，    right 右指针</span><br><span class="hljs-comment">valid  表示已经满足东西的种类</span><br><span class="hljs-comment">valid==needs.size()    表示题目的要求已经满足，可以开始缩小窗口*/</span><br></code></pre></td></tr></table></figure><h4 id="23-动态规划？？？？"><a href="#23-动态规划？？？？" class="headerlink" title="23.动态规划？？？？"></a>23.动态规划？？？？</h4><p>青蛙跳台阶问题（递归超时不可取）</p><h4 id="24-栈溢出"><a href="#24-栈溢出" class="headerlink" title="24.栈溢出"></a>24.栈溢出</h4><p>在计算机中，栈的空间是有限的，如果程序超出了系统所提供的最大栈空间，就会发生栈溢出</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-C-虚函数的定义：&quot;&gt;&lt;a href=&quot;#1-C-虚函数的定义：&quot; class=&quot;headerlink&quot; title=&quot;1.C++虚函数的定义：&quot;&gt;&lt;/a&gt;1.C++虚函数的定义：&lt;/h4&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;tabl</summary>
      
    
    
    
    
    <category term="C++" scheme="tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="2023/10/20/hello-world/"/>
    <id>2023/10/20/hello-world/</id>
    <published>2023-10-20T11:17:18.870Z</published>
    <updated>2023-10-20T11:17:18.870Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
